// Program filewriteexploitsimulator - Simulates an arbitrary file write exploit
package main

/*
 * filewriteexploitsimulator.go
 * Simulates an arbitrary file write exploit
 * By J. Stuart McMurray
 * Created 20240417
 * Last Modified 20240418
 */

import (
	"bytes"
	"cmp"
	"context"
	"errors"
	"flag"
	"fmt"
	"io"
	"io/fs"
	"log"
	"log/slog"
	"net/http"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"time"

	"github.com/magisterquis/curlrevshell/lib/sstls"
)

func main() { os.Exit(rmain()) }

func rmain() int {
	/* Command-line flags. */
	var (
		readRoot = flag.String(
			"read-root",
			"/",
			"Root `directory` for file reads",
		)
		writeRoot = flag.String(
			"write-root",
			"",
			"Root `directory` for file writes",
		)
		lAddr = flag.String(
			"listen",
			"0.0.0.0:4433",
			"Listen `address`",
		)
		basicAuth = flag.String(
			"basic-auth",
			"",
			"If set, required basic auth `username:password`",
		)
		logFile = flag.String(
			"log",
			"",
			"Optional `logfile`",
		)
		createPerms = flag.String(
			"perms",
			"0644",
			"Octal file `mode`, for file creation",
		)
		debug = flag.Bool(
			"debug",
			false,
			"Enable debug logging",
		)
		serverHeader = flag.String(
			"server-header",
			"filewriteexploitsimulator v0.0.0",
			"HTTP Server `header`",
		)
		requestTimeout = flag.Duration(
			"request-timeout",
			10*time.Minute,
			"Maximum HTTP request `duration`",
		)
	)
	flag.Usage = func() {
		fmt.Fprintf(
			os.Stderr,
			`Usage: %s [options]

Simulates an arbitrary file write exploit.  Not safe.

Options:
`,
			os.Args[0],
		)
		flag.PrintDefaults()
	}
	flag.Parse()

	/* Make sure we have something to do. */
	if "" == *readRoot && "" == *writeRoot {
		log.Fatalf("Need at least a read or a write root")
	}

	/* Set up logging. */
	var lw io.Writer = os.Stdout
	if "" != *logFile {
		lf, err := os.OpenFile(
			*logFile,
			os.O_CREATE|os.O_APPEND|os.O_WRONLY,
			0660,
		)
		if nil != err {
			log.Fatalf("Opening logfile %s: %s", *logFile, err)
		}
		defer lf.Close()
		lw = lf
		log.Printf("Logging to %s", *logFile)
	}
	var lv slog.LevelVar
	sl := slog.New(slog.NewJSONHandler(lw, &slog.HandlerOptions{
		Level: &lv,
	}))
	if *debug {
		lv.Set(slog.LevelDebug)
	}
	sl.Debug("Starting")

	/* Clean roots. */
	if "" != *readRoot {
		var err error
		*readRoot = filepath.Clean(*readRoot)
		ar, err := filepath.Abs(*readRoot)
		if nil != err {
			sl.Error(
				"Could not get absolute read root",
				"original_root", *readRoot,
				"error", err,
			)
		}
		*readRoot = ar
		sl.Debug("Read root", "path", *readRoot)
	}
	if "" != *writeRoot {
		*writeRoot = filepath.Clean(*writeRoot)
		ar, err := filepath.Abs(*writeRoot)
		if nil != err {
			sl.Error(
				"Could not get absolute write root",
				"original_root", *writeRoot,
				"error", err,
			)
		}
		*writeRoot = ar
		sl.Debug("Write root", "path", *writeRoot)
	}

	/* Work out file creation mode, if we're creating files. */
	var createMode fs.FileMode
	if "" != *writeRoot {
		n, err := strconv.ParseUint(*createPerms, 8, 32)
		if nil != err {
			sl.Error(
				"Error parsing file creation mode",
				"mode", *createPerms,
				"error", err,
			)
		}
		createMode = fs.ModePerm & fs.FileMode(n)
		sl.Debug(
			"File creation mode",
			"octal", fmt.Sprintf("%04o", createMode),
			"text", createMode.String(),
		)
	}

	/* Work out auth. */
	needUser, needPass, needAuth := strings.Cut(*basicAuth, ":")
	if needAuth {
		sl.Debug(
			"Authentication required",
			"username", needUser,
			"password", needPass,
		)
	} else {
		sl.Debug("No authentication required")
	}

	/* HTTP handler. */
	http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		/* Don't read for too long. */
		ctx, cancel := context.WithTimeout(
			r.Context(),
			*requestTimeout,
		)
		defer cancel()

		/* Logger with ALL the info. */
		sl := sl.With(
			"remote_addr", r.RemoteAddr,
			"method", r.Method,
			"request_uri", r.RequestURI,
			"protocol", r.Proto,
			"host", r.Host,
			"user_agent", r.UserAgent(),
		)

		/* Add the Server header. */
		w.Header().Set("Server", *serverHeader)

		/* Check auth. */
		user, pass, haveAuth := r.BasicAuth()
		if haveAuth {
			sl = sl.With(
				"username", user,
				"password", pass,
			)
		}
		if needAuth && "" == user && "" == pass {
			http.Error(
				w,
				http.StatusText(http.StatusUnauthorized),
				http.StatusUnauthorized,
			)
			sl.Error("Incorrect authentication")
		}
		if needAuth && (user != needUser || pass != needPass) {
			http.Error(
				w,
				http.StatusText(http.StatusUnauthorized),
				http.StatusUnauthorized,
			)
			sl.Error("Incorrect authentication")
			return
		}

		/* What we do next depends on the method and config. */
		switch {
		case "" != *readRoot && r.Method == http.MethodGet:
			/* File read. */
			p := filepath.Join(
				*readRoot,
				filepath.Clean(r.URL.Path),
			)
			sl = sl.With("path", p)
			/* If it's a directory, we'll let the http library
			handle it. */
			fi, err := os.Stat(p)
			if errors.Is(err, fs.ErrNotExist) { /* Not found. */
				http.Error(
					w,
					http.StatusText(http.StatusNotFound),
					http.StatusNotFound,
				)
				sl.Error("File does not exist")
				return
			} else if nil != err { /* Stat failed. */
				http.Error(
					w,
					err.Error(),
					http.StatusInternalServerError,
				)
				sl.Error(
					"Unable to get file info",
					"error", err,
				)
				return
			} else if fi.IsDir() { /* Directory. */
				sl.Info("Directory Request")
				http.ServeFile(w, r, p)
				return
			}
			/* Grab the file to serve. */
			f, err := os.Open(p)
			if nil != err {
				http.Error(
					w,
					err.Error(),
					http.StatusInternalServerError,
				)
				sl.Error(
					"Could not open file to read",
					"error", err,
				)
				return
			}
			defer f.Close()
			/* Flush every second, if we can. */
			go func() {
				rc := http.NewResponseController(w)
				t := time.NewTicker(time.Second)
				defer t.Stop()
				for {
					select {
					case <-t.C:
						rc.Flush()
					case <-r.Context().Done():
						return
					}
				}
			}()

			/* Read the file. */
			var rerr error
			bch := make(chan []byte, 1)
			go func() {
				defer close(bch)
				b := make([]byte, 1024)
				/* Get chunks until something goes wrong. */
				for nil == ctx.Err() && nil == rerr {
					/* Get a chunk. */
					var n int
					n, rerr = f.Read(b)
					/* Send it back if we got anything. */
					if 0 != n {
						bch <- bytes.Clone(b[:n])
					}
				}
			}()

			/* Send the file.  Timeouts are hard. */
			var (
				tot  int
				werr error
			)
			for nil == ctx.Err() && nil == rerr && nil == werr {
				select {
				case <-r.Context().Done(): /* Likely timeout. */
				case b, ok := <-bch: /* Read read. */
					/* Don't bother if we EOF'd. */
					if !ok {
						break
					}
					/* If we go anything, send it. */
					var nw int
					nw, werr = w.Write(b)
					tot += nw
				}
			}
			/* Log what we did.  Read EOFs are real errors. */
			if errors.Is(rerr, io.EOF) {
				err = nil
			}
			err = cmp.Or(rerr, werr, context.Cause(ctx))
			sl = sl.With("bytes_read", tot)
			if nil != err {
				sl.Error(
					"Error while serving file",
					"error", err,
				)
				return
			}
			sl.Info("Read file")
		case "" != *writeRoot && (http.MethodPost == r.Method ||
			http.MethodPut == r.Method):
			/* Arbitrary file write. */
			p := filepath.Join(
				*writeRoot,
				filepath.Clean(r.URL.Path),
			)
			sl = sl.With("path", p)
			/* Open the requested file. */
			f, err := os.OpenFile(
				p,
				os.O_CREATE|os.O_WRONLY,
				createMode,
			)
			if nil != err {
				http.Error(
					w,
					err.Error(),
					http.StatusBadRequest,
				)
				sl.Error(
					"Could not open file to write",
					"error", err,
				)
				return
			}
			defer f.Close()
			/* Write to it. */
			n, err := io.Copy(f, r.Body)
			sl = sl.With("bytes_written", n)
			if nil != err {
				sl.Error(
					"Error while writing file",
					"error", err,
				)
				return
			}
			sl.Info("Wrote file")
		default:
			/* Not handling this one. */
			http.Error(
				w,
				http.StatusText(http.StatusMethodNotAllowed),
				http.StatusMethodNotAllowed,
			)
			sl.Error("Unhandled request")
			return
		}
	})

	/* Set up a TLS listener. */
	l, err := sstls.Listen("tcp", *lAddr, "", 0, sstls.DefaultCertFile())
	if nil != err {
		sl.Error("Error starting network listener", "error", err)
	}
	sl.Info(
		"Starting HTTPS server",
		"address", l.Addr().String(),
		"tls_fingerprint", l.Fingerprint,
	)
	sl.Error("HTTPS server error", "error", (&http.Server{
		Handler:     http.DefaultServeMux,
		ReadTimeout: *requestTimeout,
	}).Serve(l))

	return 1
}
