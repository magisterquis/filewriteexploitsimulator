// Package tlsreconnwriter is an io.Writer which writes to a reconnecty TLS
// connection.
package tlsreconnwriter

/*
 * tlsreconnwriter.go
 * Write to a reconnecty TLS connection.
 * By J. Stuart McMurray
 * Created 20240605
 * Last Modified 20240605
 */

import (
	"context"
	"crypto/sha256"
	"crypto/subtle"
	"crypto/tls"
	"crypto/x509"
	"encoding/base64"
	"errors"
	"fmt"
	"io"
	"log/slog"
	"net"
	"strings"
	"time"
)

// InsecureSkipVerify may be used as the fingerprint in New to not do TLS
// validation.
const InsecureSkipVerify = "insecure_skip_verify"

// WriteTimeout is how long writes wait before timing out.
const WriteTimeout = 10 * time.Second

// Writer writes to a TLS connnection.  If the connection closes, reconnection
// attempts are made.
type Writer struct {
	sl             *slog.Logger
	network        string
	address        string
	fingerprint    string
	reconnInterval time.Duration

	sch chan string
	cch chan net.Conn
}

// New returns a new writer which writes to the given server.
// If fingerprint is not the empty string, the server's certificate's
// fingerprint is checked and normal TLS certificate verification is skipped.
// The fingerprint is expected to be in curl --pinnedpubkey format but also may
// be InsecureSkipVerify to skip TLS verifiation altogether.
// When a connection ends
// reconnections will happen at the given interval.  Connections and
// disconnections are logged to sl.
// The returned writer's Do method must be called to establish a connection
// and send data.
func New(
	sl *slog.Logger,
	network string,
	address string,
	fingerprint string,
	buflen int,
	reconnInterval time.Duration,
) *Writer {
	return &Writer{
		sl:             sl,
		network:        network,
		address:        address,
		fingerprint:    strings.TrimPrefix("sha256//", fingerprint),
		reconnInterval: reconnInterval,

		sch: make(chan string, buflen),
		cch: make(chan net.Conn),
	}
}

// Do connects to the server and sends buffered messages.
func (w *Writer) Do(ctx context.Context) error {
	var (
		c   net.Conn /* TLS Connection. */
		rem string   /* String which wasn't sent. */
	)
	/* Make sure the connection is closed eventually. */
	defer func() {
		if nil != c {
			c.Close()
		}
	}()

	/* Connect and send written lines. */
	for nil == ctx.Err() {
		/* Close the connection if it's broken. */
		if nil != c {
			c.Close()
		}

		/* Make sure we have a connection. */
		c, err := w.dial(ctx)
		if nil != err {
			return err
		}
		w.sl.Info("tlsreconnwriter", "state", "connected")

		/* Send as much as we can. */
		rem, err = w.sendTo(ctx, c, rem)
		w.sl.Info("tlsreconnwriter", "state", "disconnected")
		if !errors.Is(err, context.Canceled) {
			w.sl.Error(
				"tlsreconnwriter",
				"op", "send",
				"error", err,
			)
		}
	}

	return context.Cause(ctx)
}

// dial tries to connect to the server until a connection works or the
// context is cancelled.
func (w *Writer) dial(ctx context.Context) (net.Conn, error) {
	/* Try until we get a connection or the context is cancelled. */
	for nil == ctx.Err() {
		/* Try to connect. */
		c, err := w.dialTry(ctx)
		/* If we got something, life's good. */
		if nil == err {
			return c, nil
		}
		/* Nope.  Wait a bit and try again. */
		w.sl.Error("tlsreconnwriter", "op", "dial", "error", err)
		select {
		case <-time.After(w.reconnInterval):
		case <-ctx.Done():
		}
	}

	return nil, context.Cause(ctx)
}

// dialTry tries to connect to the server once.
func (w *Writer) dialTry(ctx context.Context) (net.Conn, error) {
	// Work out how to do TLS things.
	var conf tls.Config
	switch w.fingerprint {
	case "": /* Normal TLS verification. */
	case InsecureSkipVerify: /* No TLS verification. */
		conf.InsecureSkipVerify = true
	default: /* Have a fingerprint. */
		conf.InsecureSkipVerify = true
		conf.VerifyConnection = func(cs tls.ConnectionState) error {
			for _, pc := range cs.PeerCertificates {
				fp, err := pubkeyFingerprint(pc)
				if nil != err {
					return err
				}
				if 0 == subtle.ConstantTimeCompare(
					[]byte(fp),
					[]byte(w.fingerprint),
				) {
					return nil
				}
			}
			return errors.New("no matching cert found")
		}
	}
	// Dial with a context
	return (&tls.Dialer{Config: &conf}).DialContext(
		ctx,
		w.network,
		w.address,
	)

}

// sendTo sends strings from w.sch to c.
// It tries to send s first, if rem is not the empty string.
func (w *Writer) sendTo(ctx context.Context, c net.Conn, s string) (string, error) {
	/* When a read times out, connection's closed. */
	rctx, cancel := context.WithCancelCause(ctx)
	defer cancel(nil)
	go func() {
		b := make([]byte, 1)
		_, err := c.Read(b)
		if nil == err {
			err = errors.New("read returned")
		}
		cancel(err)
	}()

	/* If we have a leftover string, send it first. */
	if "" == s {
		if err := sendString(c, s); nil != err {
			return s, err
		}
	}

	/* Send strings from the channel. */
	for {
		/* Get a string to send. */
		select {
		case <-rctx.Done():
			return "", rctx.Err()
		case s = <-w.sch:
		}
		/* Try to send it out. */
		if err := sendString(c, s); nil != err {
			return s, err
		}
	}
}

// sendString sends s to w with a write deadline of WriteTimeout.
func sendString(c net.Conn, s string) error {
	if err := c.SetWriteDeadline(time.Now().Add(WriteTimeout)); nil != err {
		return fmt.Errorf("setting write deadline: %w", err)
	}
	_, err := io.WriteString(c, s)
	return err
}

// Write queues up and  does not retain b for sending to w's TLS connection and
// returns len(b), nil.
// If there is no connection established, b is buffered unless w's buffer is
// full, in which case Write blocks until there is room in the buffer.
func (w *Writer) Write(b []byte) (int, error) {
	w.sch <- string(b)
	return len(b), nil
}

// pubkeyFingerprint returns the SHA256 hash of the public key fingerprint
// for the cert.  This is used for curl's --pinnedpubkey.  If the certificate's
// Leaf isn't set, an error is returned.
func pubkeyFingerprint(cert *x509.Certificate) (string, error) {
	/* Stolen from sstls. */

	/* Marshal to nicely-hashable DER. */
	b, err := x509.MarshalPKIXPublicKey(cert.PublicKey)
	if nil != err {
		return "", fmt.Errorf("marshalling to DER: %w", err)
	}

	/* Hash and encode. */
	h := sha256.Sum256(b)
	return base64.StdEncoding.EncodeToString(h[:]), nil
}
