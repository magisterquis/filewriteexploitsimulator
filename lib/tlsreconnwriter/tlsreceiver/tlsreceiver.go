// Program tlsreceiver receives lines from tlsreconnwriter and writes them to
// a file.
package main

/*
 * tlsreceiver.go
 * Receive and save lines from tlsreconnwriter
 * By J. Stuart McMurray
 * Created 20240605
 * Last Modified 20240605
 */

import (
	"bufio"
	"errors"
	"flag"
	"fmt"
	"io"
	"log"
	"net"
	"os"
	"sync"
	"syscall"
	"time"

	"github.com/magisterquis/curlrevshell/lib/sstls"
)

func main() {
	var (
		addr = flag.String(
			"listen",
			"0.0.0.0:4321",
			"Listen `address`",
		)
		outFile = flag.String(
			"out",
			"",
			"Optional `file` to which to save received lines",
		)
	)
	flag.Usage = func() {
		fmt.Fprintf(
			os.Stderr,
			`Usage: %s [options]

Spawns a TLS server which writes lines from the connections it receives to
either stdout or, with -out, to a file.

Logs go to stderr.

Options:
`,
			os.Args[0],
		)
		flag.PrintDefaults()
	}
	flag.Parse()

	/* Start the listener listening. */
	l, err := sstls.Listen("tcp", *addr, "", 0, sstls.DefaultCertFile())
	if nil != err {
		log.Fatalf("Error listening on %s: %s", *addr, err)
	}
	log.Printf("Listening on %s, fingerprint %s", l.Addr(), l.Fingerprint)

	/* Work out where to send output. */
	of := os.Stdout
	if "" != *outFile {
		var err error
		if of, err = os.OpenFile(
			*outFile,
			os.O_CREATE|os.O_WRONLY|os.O_APPEND,
			0660,
		); nil != err {
			log.Fatalf(
				"Could not open output file %s: %s",
				*outFile,
				err,
			)
		}
	}

	/* Grab connections, log lines. */
	var (
		wg sync.WaitGroup
		mu = new(sync.Mutex)
	)
	for {
		/* Grab a new connection. */
		c, err := l.Accept()
		if errors.Is(err, syscall.ENFILE) ||
			errors.Is(err, syscall.EMFILE) {
			time.Sleep(time.Second)
			continue
		}
		if nil != err {
			log.Printf("Error accepting new clients: %s", err)
			break
		}
		/* Send for handling. */
		wg.Add(1)
		go handle(of, c, mu, &wg)
	}
	log.Printf("Listener died, waiting for connections to close")
	wg.Wait()
	log.Printf("Goodbye.")
}

// handle reads lines from c and writes them to w.
func handle(w io.Writer, c net.Conn, mu *sync.Mutex, wg *sync.WaitGroup) {
	defer wg.Done()
	defer c.Close()

	ra := c.RemoteAddr().String()
	log.Printf("[%s] New connection", ra)

	/* Proxy lines from c to w. */
	scanner := bufio.NewScanner(c)
	for scanner.Scan() {
		/* Grab a line. */
		l := scanner.Text()
		if "" == l {
			continue
		}
		/* Write it. */
		mu.Lock()
		_, err := fmt.Fprintf(w, "%s\n", l)
		mu.Unlock()
		if nil != err {
			log.Printf(
				"[%s] Error writing %s: %s",
				ra,
				l,
				err,
			)
			return
		}
	}
	/* Something went wrong. */
	if err := scanner.Err(); nil != err {
		log.Printf("[%s] Read error: %s", ra, err)
		return
	}
	log.Printf("[%s] Disconnected", ra)
}
